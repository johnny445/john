







Introducing Elastic Beanstalk and Elastic File System
Elastic Beanstalk, a service that can help you develop and deploy rich web applications in just a few clicks, and Elastic File System, a service that provides a massively scalable shared filesystem for your EC2 instances! So, keeping this in mind, let's have a quick look at the various topics that we will be covering in this task:
Introducing Elastic Beanstalk and how it works
How to manage applications, environments, and configurations with ease using Elastic Beanstalk
Pushing your applications to AWS using the Elastic Beanstalk CLI
Getting started with Elastic File System and its various use cases
Hosting a highly scalable and available WordPress site using Elastic Beanstalk and Elastic File System
So much to do, so let's get started right away!


Introducing Amazon Elastic Beanstalk
One of the key features of a cloud is to provide its users and developers with a seamless and easy to use platform for developing and deploying their applications. That's exactly where Elastic Beanstalk comes in. Elastic Beanstalk was first launched in the year 2011, and has continuously evolved to become a full-fledged PaaS offering from AWS.
Elastic Beanstalk is your one-stop shop for quickly deploying and managing your web applications in AWS. All you need to do is upload your code to Beanstalk, and voila! Elastic Beanstalk takes care of the entire application's deployment process, from EC2 capacity provisioning to auto-scaling the instances and even load balancing using an ELB! Elastic Beanstalk does it all so that you can concentrate on more important tasks, such as developing your applications and not getting bogged down with complex operational nuances.
But for me, Beanstalk is much more than just the deployment and management of your applications. Let's look at some of the key benefits of leveraging Elastic Beanstalk for your web applications:
Deployment support: Today, Beanstalk supports standard EC2 instances and Docker containers as the basis for your application's deployment. This enables you to host your web applications and your microservices-based apps on AWS with relative ease.
Platform support: Beanstalk provides a rich set of platforms for developers to deploy their apps on. Today, the list includes Java, PHP, Python, .NET, Node.js, and Ruby, with more languages and platforms to be added in the future.
Developer friendly: It is extremely easy to build and deploy your applications over to AWS using Beanstalk. You can leverage a wide variety of options, including the AWS Management Console or its CLI, a code repository such as Git, or even an IDE such as Eclipse or Visual Studio to upload your application, and the rest is all taken care of by Beanstalk itself.
Control: With Beanstalk, you get complete control over your underlying AWS resources as well as the environments on which your application runs. You can change the instance types, scale the resources, add more application environments, configure ELBs, and much more!
Costs: One of the best things about Beanstalk is that it's absolutely free! Yes, you heard it right! Free! You only pay for the AWS resources that are spun up based on the configurations that you provide and nothing more. Amazing isn't it?


With these pointers in mind, let's look at some of the essential concepts and terminologies that you ought to know before getting started with Elastic Beanstalk.

Concepts and terminologies
Here's a look at some of the common concepts and terminologies that you will often come across while working with Elastic Beanstalk:
Applications: An application in Elastic Beanstalk is basically a collection of Beanstalk's internal components, and includes environments, versions, events, and various other things. Think of an Elastic Beanstalk application as a high-level container which contains different aspects of your application.
Application versions: Application versions are nothing more than different versions of an application's code. Each version of your application's code is stored in an S3 Bucket that is auto-created and managed by Beanstalk itself. You can create multiple versions of your application code and use this for deployment to one or more environments for testing and comparison.
Environments: An Elastic Beanstalk environment is yet another logical container that hosts one application version at a time on a specified set of instances, load balancers, auto scaling groups, and so on. Typically, you would have an environment for development, one for acceptance testing, and another one for production hosting, however, there are no hard and fast rules on this.

An environment comes in two flavors, and you can choose between the two during your initial environment setup phase. The first is called a web server environment, and is basically created for applications that support HTTP requests, such as web applications and so on. The second is called a worker environment, where the application pulls tasks from an Amazon SQS Queue. Here's a look at each of these flavors in a bit more detail:
Web server environment: As mentioned earlier, this particular environment is well suited to hosting and managing web frontend applications, such as websites, mobile applications, and so on. As part of this environment, Beanstalk provisions an internet-facing Elastic Load Balancer, an autoscaling group with some minimalistic configuration settings, and a small number of EC2 instances that contain your application code along with a pre-installed agent called Host Manager. The Host Manager agent is a key component in the entire setup process, as it is responsible for deploying and monitoring the application as well as periodically patching the instance and rotating the logs.





Here's a representational diagram depicting a simple application being scaled using a web server environment. Note the RDS instance in the diagram as well. You can also choose to set up an RDS instance for your application using Elastic Beanstalk, or add it to the application stack manually later:


An additional point worth mentioning here is that every environment has a unique CNAME, for example mywo rdpre s s. The CNAME maps to a URL which is in the form of mywo rdp re s s . u s—
ea st —1 . e la st i cbe an st alk . com. This URL is aliased in Amazon's DNS
service Route53 to an Elastic Load Balancing URL, something like
abcde f—1 2 3 4 5 6 . u s—ea sC—1 . e lb . ama z onaw s . com, by using a CNAME
record.


Worker environment: The worker environment works in a very different way to the web server environment. In this case, Elastic Beanstalk starts up an SQS Queue in your environment and installs a small daemon into each of the worker instances. The daemon is responsible for regularly polling the queue for newer messages, and if a message is present, the daemon pulls it into the worker instance for consumption, as depicted in the following diagram:


Ideally, you can use a combination of web and worker environments to host your applications, so that there is a clear decoupling of your web frontend resources and your backend processing worker instances. Keep in mind that there are a lot more design considerations that you also ought to think about while setting up your environments, such as how the scalability is going to be handled and storage options for data depending on the type of data, for example S3 for logs and RDS for application-centric data, security, fault tolerance, and much more.
With this section completed, let's move on to the fun part and see how to get started with using Elastic Beanstalk!









[ 57 ]


Getting started with Elastic Beanstalk
In this section, we will be performing a deep dive into how to set up a fully-functional Dev and Prod environment for our simple WordPress application using Elastic Beanstalk. Before we get started, here is a list of some prerequisite items that you need to have in place before we can proceed:
A valid AWS account and user credentials with the required set of privileges to run the AWS CLI and the Elastic Beanstalk CLI.
A sandbox/Dev instance to download the WordPress installation and later use it to push the application code over to the respective Beanstalk environment. Note that you can also use other resources, such as a Git URL or an IDE, but for now we will be focusing on this approach.


Creating the Dev environment
Let's first start off by creating a simple and straightforward development environment for our WordPress site. To do so, execute the following steps:
Sign in to the AWS Console and select the Elastic Beanstalk option from the Services filter, or alternatively, launch the Elastic Beanstalk console by launching
theURLhttps://console.aws.amazon.com/elasticbeanstalkfiabrowsero1
your choice.
Next, select the Create New Application option to get started. Remember, an application is the highest level of container for our application code, which can contain one or more environments as required.
In the Create New Application dialog box, provide a suitable Application Name and an optional Description to get started with. Click on Create once completed.
With the basic application container created, you can now go ahead and create the development environment. To do so, from the Actions drop-down list, select the Create New Application option.
Here, you will be provided with an option to either opt for the Web
　server environment or the Worker environment configuration. Remember, an environment type can be selected only once here, so make sure that you select the correct tier based on your application's requirements. In this case, I've opted to select the Web server environment, as shown in the following screenshot:



[58]




On the Create a new environment wizard page, provide a suitable Environment name for your WordPress site. Since this is a development environment, I've gone ahead and named it YoyoHo rdpres s -dev. Next, in the Domain field, provide a unique name for your website's domain URL. The URL will be suffixed by the region-specific Elastic Beanstalk URL, as shown in the following screenshot:



Next, type in a suitable Description for your new environment, and move on toward the Base configuration section. Here, from the Platform dropdown, select the Preconfigured platform option and opt for the PHP platform, as depicted in the following screenshot. PHP is our default option as WordPress is built on PHP
　5.6. Today, Beanstalk supports packer builder, Docker containers, Go, Java SE, Java with Tomcat, .NET on Windows Server with IIS, Node.js, PHP, Python, and Ruby, with more platform support coming shortly:


Now, here's the part where you need to keep your calm! Leave the rest of the options as their default values and select Configure more options, not the Create environment option! Yes, we will be configuring a few additional items first and will create our development environment later!
On the Configure Environment page, you can opt to select one of the three preconfigured Configuration presets options, based on your application's requirements. The presets are briefly explained here:
Low cost (Free tier eligible): This particular configuration will launch a single (t2.micro) instance with no load balancing or autoscaling group configured. This is ideal if you just want to get started with an application using the basics or wish to set up a minimalistic Dev environment, as in this case.
High availability: Unlike the low-cost preset, the high-availability configuration comes pre-equipped with an autoscaling group that can scale up to a default of four instances or more, and an Elastic Load Balancer that has cross-zone load balancing and connection draining enabled by default. Besides this, you also get a host of CloudWatch alarms created for monitoring, as well as security groups for your instance and Load Balancer.
Custom configuration: You can additionally opt to configure your environment based on other parameters. You can select this preset, and modify each and every component present within your environment as you see fit.


With the Configuration preset set to Low cost (Free tier), the next item that we can modify is the Platform configuration. Elastic Beanstalk supports the following PHP platform configurations:

PHP Language Amazon Linux AMI PHP version
PHP 7.1	2017.03.1	PHP 7.1.7
PHP 7.0	2017.03.1	PHP 7.0.21
PHP 5.6	2017.03.1	PHP 5.6.31
PHP 5.5	2017.03.1	PHP 5.5.38
PHP 5.4	2017.03.1	PHP 5.4.45
Since we are using a WordPress application, we need to modify the platform as well, to accommodate for the correct PHP version.

To do so, select the Change platform configuration option. This will bring up the Choose a platform version dialog, as shown here:


Here, from the drop-down list, search and select the 64bit Amazon Linux 2017.03 v2.5.0 running PHP 5.6 option, as WordPress execution is stable with PHP 5.6. Once done, click on Save to complete the process.
With the Platform configuration changed as per our requirements, we can now move on to configuring the add-on services such as security, notifications, network, database, and much more! For example, let's quickly configure the networking for our WordPress Dev environment by selecting the Modify option in the Network pane.


In the Network pane, you can opt to launch your environment in a custom VPC, as well as other instance-specific settings such as enabling Public IP address, selecting the Instance subnets based on your VPC design, and finally assigning Instance security groups for your Dev instances. In this case, I already have a custom VPC created specifically for the development environment that contains one public subnet and one private subnet, with a default security group as well. Here is an overview of the network configuration setup for my environment. You can tweak this to match your requirements:


Once the settings are made, click on Save to complete the networking changes. You can perform other configurational changes as you see fit, however, since this is only a development environment, I've opted to leave the rest of the options as default for now. Once completed, select the Create environment option to finish the environment creation process.


Once the environment creation process is initiated, it will take a couple of minutes to complete its execution, as depicted in the following screenshot. Here, you will see Elastic Beanstalk create a new security group as well as an Elastic IP address for your EC2 dev instance. During this stage, the environment also transitions from a Pending to an Ok state, and you can view the environment, your application's logs, and the status:


　With your environment up and running, you can also verify it using the URL provided as an output of your environment's creation by using the environment dashboard. Upon selecting the URL, you will be redirected to a new application landing page in your web browser which basically verifies that your environment is configured to work with PHP 5.6.
But where is our WordPress application? That's exactly what we will be deploying next using a really simple and easy-to-use Elastic Beanstalk CLI.


Working with the Elastic Beanstalk CLI
　With your environment deployed using the AWS Management Console, we now shift our focus to leveraging the Elastic Beanstalk CLI, or EB CLI, to push the application code over to the newly created environment.
The EB CLI is a powerful utility that can be used to operate and manage your entire Elastic Beanstalk environment using a few simple CLI commands. It is also designed to work with AWS development services such as CodeBuild and CodeCommit, as well as other third- party code repository services such as Git.
In this section, we will first be looking at a few simple steps for installing the EB CLI on a simple Linux instance, later followed by configuring and pushing our WordPress application to its respective development environment:
To do so, we first need to ensure that the instance is updated with the latest set of packages. In my case, I'm performing the steps on a simple Ubuntu 14.04 LTS instance, however, you can alternatively use your own on-premises virtual machines.
Run the following command to update your OS. The command will vary based on your operating system variant:

# sudo apt-get update

Next, we need to ensure that the instance has the required Python packages installed in it. Note that if you are using the Amazon Linux AMI, then by default it will already have the necessary Python packages installed in it:

# sudo apt-get install python python-pip
AWS CLI and the EB CLI require Python 2 version 2.6.5+ or Python 3 version 3.3+.


With the Python packages installed, we now move forward and set up the AWS CLI using the following commands:

# pip install awscli
# aws configure


The first command installs the CLI, while the other runs you through a simple wizard to set up the AWS CLI for your instance. To learn more about how to configure the AWS CLI, you can check out this URL: hot.p: / /
docs.aws.amazon.com/cli/latest/userguide/installing.html.

Finally, we go ahead and install the EB CLI. The installation is pretty straightforward and simple:

# pip install awsebcli

That's all there is to it! You now have a functioning Elastic Beanstalk CLI installed and ready for use. So let's now go ahead and download the required WordPress code ZIP file locally and use the EB CLI to push it into the development environment:

# sudo git clone https://github.com/WordPress/WordPress.git

Extract the contents of your WordPress ZIP file into a new folder, and run the following command from within the WordPress directory:

# eb init

　The eb init command is used to initialize and sync the EB CLI with your newly created development environment. Follow the on-screen instructions to configure the EB CLI's settings, such as Selecting a default region to operate from, Selecting an application to use, and so on. Remember, the default region has to match your current development environment's region as well, which in my case is us-east-1:
With the EB CLI set up, the only step left now is to deploy the WordPress application to the development environment using yet another EB CLI command called simply eb deploy:

# eb deploy


　During the deployment process, the CLI creates an application version archive in a new S3 bucket within your environment. Each application deployment will result in subsequent version creations within S3 itself. After this, you will see your application code get uploaded to your development environment, as depicted in the following screenshot:


The environment simultaneously changes its state from Ok to Pending as the application is uploaded and set up in your development instance. Once the application becomes available, the health state of the environment will yet again transition from Pending to OK to Info.
You can verify whether your application has uploaded or not by refreshing the applicaGonUKL(yoyoclouds.us—east—1.elasticbeanstalk.com)onyour environment's dashboard. You should see the WordPress welcome screen, as shown in the following screenshot:


Note, however, that this setup still requires a MySQL database, so don't forget to go to the RDS Management Console and create a minimalistic MySQL database, or even better, an Aurora DB instance, for your development environment. Remember to note down the database username, password, and the DB host and database name itself; you will need these during your WordPress configuration!

[ 66 ]


　With this step completed, let's take a few minutes to understand the various options for configuring and monitoring your newly deployed application using the environment dashboard!

Understanding the environment dashboard
The environment dashboard is your one-stop shop for managing and monitoring your newly deployed applications, as well as the inherited instances. In this section, we will quickly look at each of the sections present in the environment dashboard and how you can leverage them for your applications.
To start off with, the Dashboard view itself provides you with some high-level information and event logs depicting the current status of your environment. To learn more about the recent batch of events, you can opt to select the Show All option in the Recent
Events section, or alternatively select the Events option from the navigation pane.
　The Dashboard also allows you to upload a newer version of your application by selecting the Upload and Deploy option, as shown in following screenshot. Here, you can see a Running Version of your WordPress application as well. This is the same application that we just deployed using the EB CLI.
You can also control various aspects of your environment, such as Save Configuration, Clone Environment, and Terminate Environment, as well using the Actions tab provided in the right-hand corner of the environment dashboard:



Moving on from the Dashboard, the next tab in the navigation pane that is worth checking out is the Configuration section. Let's look at each of the configuration options in a bit more detail, starting off with the Scaling tile:
Scaling: Here, you can opt to change your Environment Type from a Single instance deployment to a Load balancing, auto scaling enabled environment simply by selecting the correct option from the Environment Type drop-down list. You can even enable Time-based scaling for your instances by opting for the Add scheduled action option.
Instances: In the next tile, you can configure your instance-specific details for your environment, such as the Instance type, the EC2 key pair to be used for enabling SSH to your instances, the Instance profile, and other options as well, such as the root volume type and its desired size.
Notifications: Here, you can specify a particular Email address, using which, notifications pertaining to your environment—such as its events—are sent using the Amazon SNS.
Software configuration: This section allows you to configure some key parameters for your application, such as the application's Document root, the Memory limit for running your PHP environment, and the logging options. But the thing that I really love about the software configuration is the Environment properties section. With this, you can pass secrets, endpoints, debug settings, and other information to your application without even having to SSH into your instances, which is simply amazing! We will be learning a bit about environment properties and how you can create simple environment variables and pass them to your WordPress application a bit later in this task.
Health: One of the most important configuration items in your environment, the Health section allows you to configure the Health Check URL for your application, as well as to enable detailed health reporting for your environment using a special agent installed on your systems. This agent monitors the vitals of your EC2 instance, captures application-level health metrics, and sends them directly to Beanstalk for further analysis. This, in conjunction with the Application Logs, helps you to drill down into issues and mitigate them all using the Elastic Beanstalk Console itself.
NOTE: You can find the agent's logs in your instance's
/var/log/healthd/daemon.log11e.


Apart from the Configuration tab, Elastic Beanstalk also provides you with a Logs option, where you can request either the complete set of logs or the last 100 lines. You can download each instance's log files using this particular section as well:


　And last but not least, you can also leverage the Monitoring and Alarms sections to view the overall Environment Health, as well as other important metrics, such as CPU Utilization, Max Network In, and Max Network Out. To configure the alarms for individual graphs, all you need to do is select the alarm icon adjoining each of the graphs present in the Monitoring dashboard, as shown in the following screenshot:


A corresponding Add Alarm widget will pop up, using which you can configure the alarm's essentials, such as its Name, the Period, and Threshold settings, as well as the required Notification settings.


In this way, you can use the environment dashboard and the EB CLI together to perform daily application administration and monitoring tasks. In the next section, we will be leveraging this environment dashboard to clone and create a new production environment from the existing development environment.

Cloning environments
　With the development environment all set and working, it is now time to go ahead and create a production environment. Now, technically, you could repeat all the processes that we followed earlier for the development environment creation, and that would work out well indeed, but Elastic Beanstalk offers a really simple and minimalistic approach to creating new environments while using an existing one as a template. The process is call cloning, and it can be performed in a few simple clicks, using the environment dashboard itself:

To get started, simply select the Actions tab from the environment dashboard page and select the option Clone Environment. This will bring up the New Environment page, as shown here:



Here, start off by providing an Environment name for the new environment, followed by a unique prefix for the Environment URL. Remember, this is a clone from the earlier development environment that we created, so, by default, it will contain the same Amazon Linux instance with the WordPress application that we pushed in during the Dev stages. This is not a concern as we can always use the EB CLI to push the production version of the application as well. But for now, fill in the rest of the details and select the Clone option.

　The new environment undergoes the same initialization and creation process as it did earlier, creating separate security groups, assigning a new Elastic IP, and launching a new EC2 instance with the same application version that was pushed in the development environment.
Once completed, you should now have two very similar environments up and running side by side, but isn't a production environment supposed to be more than just one instance?
Well, that's precisely what we will be configuring in the next section.

Configuring the production environment
Now that we have had a good tour of the environment dashboard, it should be relatively easy to configure the production environment as per our requirements. Let's start off by increasing the instance count for our production environment:
Select the Scaling configuration tile from the newly created production environment's configuration dashboard and change the Environment type from Single instance to Load balancing, auto scaling. The instance count settings as well as the auto scaling features, will only be available once the new changes are reflected in the environment. Click Apply once done.

To verify that the changes have indeed been propagated, you can copy the newly created Elastic Load Balancer DNS name into a web browser and verify that you can access the WordPress getting started wizard.

Next, you can also change the default instance type from t1.micro to something a bit more powerful, such as t2.medium or t2.large, using the
Instances configuration section.
Once your major settings are done, you will also require a new RDS backed MySQL database for your production instances. So go ahead and create a new MySQL DB instance using the RDS Management Console at ht hps: / / con so le .
aws.amazon.com/rds/.


For handling production-grade workloads, I would strongly recommend enabling multi-AZ deployment for your MySQL database.


Remember to make a note of the database name, the database endpoint, as well as the username and password, before moving on to the next steps!
Next, using the production environment URL, launch your WordPress site and fill in the required database configuration details, as depicted in the following screenshot:


This method of configuring database settings is not ideal, especially when it comes to a production environment. Alternatively, Elastic Beanstalk provides you with the concept of environment properties that enable you to pass key- value pairs of configurations directly to your application.




[ 72 ]


To do so, you need to select the Configuration section from your Production dashboard, and within that, opt to modify the Software configuration.
Here, under the Environment Properties section, fill out the required production database variables, as depicted in the following screenshot:


But where do these variables actually end up getting configured? That's where we leverage the WordPress configuration file called wp-
　config . php and configure all these variables into it. Upon loading, PHP will read the values of each of these properties from the environment property that we just set in Elastic Beanstalk.
Open your up-config . php file using your favorite text editor, and change the database section, as shown in the following snippet:

/** The name of the database for WordPress */ define('DB_NAME', getenv('DB_NAME')),

/** MySQL database username */ define('DB_USER', getenv('DB_USER')),

/** MySQL database password */ define('DB_PASSWORD', getenv('DB_PASSWORD')),

/** MySQL hostname */ define('DB_HOST', getenv('DB_HOST')),

Save the file and push the newly modified code into the production environment using the eb deploy Command. Simple isn't it?


Here's what the new environment should look like after the deployments:


　Looking good so far, right? With this done, your WordPress setup should be able to scale in and out efficiently without you having to worry about the load balancing needs or even about the MySQL instances. Additionally, now that we have configured the instances to fetch the database information from Elastic Beanstalk itself, we no longer have to worry about what will happen to our site if the underlying WordPress instances restart or terminate. This is exactly what we set out to do in the first place, but there's still a small catch. What about the content files that you will eventually upload on your WordPress website, such as images and videos? These uploads will end up getting stored on your instance's local disks, and that's a potential issue as you may end up losing all of your data if that instance gets terminated by the auto-scaling policies. Luckily for us, AWS has a solution to this problem, and that's exactly what we are going to learn about next.


Introducing Amazon Elastic File System
　AWS, for one, has really put in a lot of innovation and effort to come up with some really awesome services, and one such service that I personally feel has tremendous potential is the Elastic File System. Why is it so important? Well, to answer this question, we need to take a small step back and understand what type of storage services AWS offers at the moment.
First up, we have the object stores in the form of Amazon S3 and Amazon Glacier. Although virtually infinite in scaling capacity, both these services are known to be a tad slower performance-wise compared to the EC2 instance storage and the EBS. This is bound to happen, as the likes of EBS is specially designed to provide fast and durable block storage, but, as a trade-off, you cannot extend an EBS volume across multiple Availability Zones.
　Elastic File System or EFS, on the other hand, provides a mix of both worlds by giving you the performance of an EBS volume combined with the availability of the same volume across multiple AZs, and that is really awesome! To summarize, EFS is a massively scalable file storage system that allows you to mount multiple EC2 instances to it simultaneously across AZs, without having to worry about the durability, availability, or performance of the system.
How does EFS actually work, you ask? Well, that's exactly what we will learn about in the next section.

How does it work?
　EFS works in a very simple and minimalistic way, so as to reduce the amount of configurations that you need to perform and manage as an end user. To start off, EFS provides you with the ability to create one or more filesystems. Each filesystem can be mounted to an instance or instances, and data can be read as well as written to them. Mounting the filesystem requires your instances to have support for the Network File System version 4.0 and 4.1 (NFSv4) protocol. Most Linux operating systems come with the necessary support, however, you may have to install the NFS client on these machines if it is not there to connect to an EFS. So, how is this useful for our WordPress application? Well, for starters, once you have an Amazon Elastic File System in place, you can have multiple EC2 instances connect to it simultaneously and use it as a scalable shared drive that can extend even to petabytes if the need arises. Also, the Amazon Elastic File System does not have any downtime or repercussions if your EC2 instances reboot or even terminate; the data will persist on the filesystem until you manually delete it or terminate the filesystem itself. There are some rules and limitations, however, when it comes to using the Elastic File System, which you ought to keep in mind.


You can mount an Amazon EFS on instances in only one VPC at a time, and both the filesystem and the VPC must be in the same AWS region.
Once the filesystem is created, you will be provided with a DNS name for identifying it within your region. Additionally, you will also be required to create one or more supporting mount targets within your VPC, which basically acts as a connectivity medium between your instances present within a subnet and the filesystem. Here is a representational diagram of how an Elastic File System interacts with EC2 instances using mount targets:


　As an administrator, you can create one mount target in each Availability Zone present in a given region. You can also create a mount target in each of the subnets presents within a particular VPC, so that all EC2 instances in that VPC share that mount target. In the next section, we will be exploring a few simple steps required for setting up your own Elastic File System.







Creating an Elastic File System
Setting up your own Elastic File System is as easy as it gets! You can start off by launching the Elastic File System dashboard from the AWS Management Console, or alternatively, by visiting the URL http s : / / con sole . aws . ama z on . com/ e f s /:

On the EFS landing page, select the option Create file system to get started.
In the Configure file system access page, you can start off by first selecting the VPC you want to associate the filesystem with. Remember, you can have multiple filesystems per VPC, however, they cannot be extended across regions:


With the VPC selected, the associated subnets will automatically populate themselves based on the Availability Zones that they are a part of in the Create mount targets section. Here, you can select the appropriate subset that you wish to associate with the Elastic File System, along with its corresponding security group. In my case, I've selected the individual public subnets from my VPC, as the WordPress application instances will be deployed here, and these instances will require access to the filesystem for storing the images and other content.
With the fields populated, select the Next Step option to proceed.


The next step is all about Configuring optional settings for your Elastic File System. Here, you can Add tags to describe your filesystem and select the appropriate Performance mode for the filesystem, based on your requirements. Today, EFS provides two modes: the General Purpose, which is ideal for running the majority of workloads, and a Max I/O mode, which is specifically designed for when your environment needs to scale to tens of thousands of EC2 instances, all connecting to this single filesystem itself. Max I/O mode provides much better performances compared to General Purpose, however, there is the chance of a slightly higher latency when handling file operations here.
The final option left is Enable encryption, which, if checked, will leverage a KMS key from your existing AWS account and encrypt all the data stored in the filesystem at rest:


Complete the EFS setup process by reviewing the configuration changes on the Review and create page, and finally, click on Create to enable the filesystem. This process takes a couple of minutes, but once completed, you will be shown the DNS name of your newly created filesystem. Make a note of this name as you will be required to reference it in our Elastic Beanstalk environment as well.


So far, so good! We have our production environment up and running on Elastic Beanstalk, and now we have created a simple yet powerful Elastic File System. In the next section, we will look at how you can integrate the two services for use by WordPress using Elastic Beanstalk's configuration files concept.

Extending EFS to Elastic Beanstalk
　Although Elastic Beanstalk takes complete care of your environment's provisioning and configuration, there are still methods which you can used to control the advanced configuration of your environment, such as integrating your application with the likes of other AWS services, such as ElastiCache, or even EFS for that matter. This can be performed using a variety of services provided by Beanstalk itself; for example, by leveraging Beanstalk's Saved configurations, or even using Environment Manifest (YML) files. But in this particular section, we will be concentrating on integrating the EFS service with our WordPress application using specialized Configuration Files called . ebext ens ions.
　These . ebext.en s i on s are simple YAML formatted documents ending with a . con f iq file extension. Once the . ebexL en s i on s file is created, you need to place this in the root folder of your application's source code, within a special directory named . ebexL en s ion s, and finally, deploy your application over to Beanstalk.
　These configuration files are so powerful that you don't even have to connect to your instances through SSH to issue configuration commands. You can configure your environment entirely from your project source by using . ebext en s ions:
To start using . ebexL en s ion s for your WordPress setup, first we need to create a folder named . ebexL en s i on s within the root of your WordPress application. Type the following command from your Dev instance:

# cd wordpress && sudo mkdir .ebextensions
Create a new file with an extension of . con f i q, and paste the following contents into it:

# sudo vi efs.config

### PASTE THE FOLLOWING CONTENTS ###
packages: yum:
nfs—utils: []
Jq: []
files:


"/tmp/mount—efs.sh" mode: "000755" content:
#!/usr/bin/env bash mkdir —p /mnt/efs
　　　　EFS_NAME=$(/opt/elasticbeanstalk/bin/get—config environment jq —r '.EFS_NAME')
　　　　mount —t nfs4 —o nfsvers=4.1,rsize=1048576,wsize=1048576,hard,timeo=600,retrans=2
$EFS_NAME:/ /mnt/efs I l true mkdir —p /mnt/efs/uploads
　　　　chown webapp:webapp /mnt/efs/uploads commands:
01—mount:
　　　command: "/tmp/mount—efs.sh" container_commands:
01—rm—wp—content—uploads:
　　command: rm —rf /var/app/ondeck/wp—content/uploads 02—symlink—uploads:
　　　command: ln —snf /mnt/efs/uploads /var/app/ondeck/wp— content/uploads
You can find the complete copy of the previous code at hfifip s : / / qifihub .
com/yoyoclouds/Administering—AWS—Volume2.



This file causes Elastic Beanstalk to mount the newly created EFS volume on the instance's
　/mnt. / e f s directory, and also removes the wp—cont end / up l oads, directory if it exists, and symlinks it to /mnt / e f s / up1 oads so that it persists and is shared between instances:
Once the file is created, use the eb deploy command once again to push the application directory and the newly added . ebexL ens ions directory to your production environment.
Last but not least, sign in to your production environment and select the Configuration option from the environment dashboard. Here, select the Software configuration tile and add the following key-value pair into the Environment Properties section, as shown:




Here, the EFS_NAME has to have the newly created EFS filesystem's DNS name as its value. This is the same DNS name that we copied a while back once the EFS was created.

Once the deployment changes states and is made available, select the environment URL and verify whether the WordPress configurations are all working as intended or not. If you have made it this far, then you should have a really awesome, highly available, scalable, WordPress site up and running! Awesome, isn't it?


Planning your next steps
Well, we have covered a lot of new features and services in this task, however, there are still a few things that I would recommend you try out on your own. First up is Elastic Beanstalk's advanced configurations.
　As mentioned earlier, Beanstalk provides a lot of different ways for you to customize and extend your application with other AWS services using a variety of built-in services such as
. ebexC en s ions, which we covered in the previous section. One similar service that can be
　used to configure a Beanstalk environment's configuration is called the environment manifest file. This is a simple YAML file containing your environment's manifest configurations, such as the environment name, solution stack, and environment links to use when creating your environment. The file is placed in your application's root directory and is generally named env . yarns. One of the key uses of this file is to provide support for environment links that enable you to connect two application environments using simple names as references.


For example, if you have a website as a front-ending application that accepts certain inputs from the users, and another application that processes these inputs, you can create a link between the worker and the frontend application using this env . ym1 file. On invocation, the link between these two environments is set up and managed automatically by Beanstalk.
Here's a small snippet of the env . yml file's contents:

AWSConfigurationTemplateVersion: 1.1.0.0 SolutionStack: 64bit Amazon Linux 2015.09 EnvironmentName: frontend—environment EnvironmentLinks:
"WORKERQUEUE" : "worker—environment"

You can learn more about Enrironmenf Manifest (env.yaml) at https:/ /docs . aws . ama zon .
com/elasticbeanstalk/latest/dg/environment—cfg—manifest.html.

　Alternatively, Beanstalk also provides you with an easier configuration saving mechanism, which you can invoke using either the environment dashboard or the EB CLI. This is called a Saved Configuration and can be enabled by selecting the Save configuration option under the Actions tab in your environment dashboard. Once applied, the environment configurations accept any custom configurations that are stored in an S3 bucket as an object. You can even download this configuration object and create clones of your environment using the EB CLI. To learn more about saved configurations, check out this URL: http: / /
　docs.aws.amazon.com/elasticbeanstalk/latest/dg/environment—configuration— savedconfig.html
Another very interesting thing worth exploring is the support for Docker containers provided in Elastic Beanstalk! As you may already be aware, Docker containers are the next big thing when it comes to creating microservices-backed applications that can be deployed and scaled at tremendous scale. The Docker platform for Elastic Beanstalk has two generic configurations, a single container and multi-container option, and also provides several preconfigured container images to choose from.
From an Elastic File System perspective, one key aspect that is worth reading and exploring is the filesystem's overall performance considerations. This documentation especially highlights the different performance levels and use cases compared to EBS-provisioned IOPS volumes. The document also provides some keen insights and considerations for how to maximize the filesystem's performance. You can check out the documentation at ht Cp: / /
docs.aws.amazon.com/efs/latest/ug/performance.html.


Summary
So, here we are. Yet another task comes to an end! But, before we move on to the next task, here's a quick round up of the things we have learned so far.
　We started off with a quick introduction to Amazon Elastic Beanstalk, followed by a dive into its concepts and terminologies. Then we created a simple development environment for our WordPress application using the Elastic Beanstalk management console and the EB CLI.
　Along the way, we also learnt how to deploy the application to a specific environment using the EB CLI, and finally, learned how to quickly clone an environment and configure it for handling production workloads. Last but not least, we explored and learned how to leverage Elastic File System to create a durable and scalable file sharing system to be used by our WordPress setup, and concluded the task with some key insights and next steps.
In the next task, we will be starting off by exploring some security services in the form of WAF and Shield. So, stay tuned—we still have a lot to learn!
